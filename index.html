<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Scratch & Reveal</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Sans:wght@300;400&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  html, body {
    height: 100%;
    width: 100%;
    overflow: hidden;
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    -webkit-user-select: none;
  }

  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #0d0d0d;
    font-family: 'DM Sans', sans-serif;
    color: #fff;
    padding: 16px;
    gap: 0;
  }

  h1 {
    font-family: 'Bebas Neue', cursive;
    font-size: clamp(1.6rem, 7vw, 3rem);
    letter-spacing: 0.12em;
    color: #ff2b2b;
    margin-bottom: 4px;
    text-shadow: 0 0 24px rgba(255,43,43,0.5);
    line-height: 1;
  }

  .subtitle {
    font-size: clamp(0.6rem, 2.5vw, 0.75rem);
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: #444;
    margin-bottom: clamp(10px, 2.5vw, 18px);
  }

  .canvas-wrapper {
    position: relative;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 0 0 1px #222, 0 20px 60px rgba(0,0,0,0.9);
    flex-shrink: 0;
  }

  /* The actual image sits behind */
  #reveal-image {
    display: block;
    width: 100%;
    height: 100%;
    object-fit: cover;
    pointer-events: none;
    -webkit-user-drag: none;
  }

  /* Canvas sits on top — fully opaque red, destination-out punches clean holes */
  #scratch-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    cursor: crosshair;
    touch-action: none;
    /* IMPORTANT: no opacity, no filter — must be fully opaque so destination-out shows clean image */
  }

  .progress-bar-wrap {
    margin-top: 12px;
    height: 3px;
    background: #1c1c1c;
    border-radius: 99px;
    overflow: hidden;
    flex-shrink: 0;
  }

  .progress-bar {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #ff2b2b, #ff8800);
    border-radius: 99px;
    transition: width 0.08s linear;
  }

  .hint {
    margin-top: 10px;
    font-size: clamp(0.58rem, 2vw, 0.68rem);
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: #2e2e2e;
    text-align: center;
    flex-shrink: 0;
  }

  .reset-btn {
    margin-top: clamp(10px, 2.5vw, 18px);
    background: none;
    border: 1px solid #2a2a2a;
    color: #555;
    font-family: 'DM Sans', sans-serif;
    font-size: clamp(0.65rem, 2.5vw, 0.75rem);
    letter-spacing: 0.18em;
    text-transform: uppercase;
    padding: 10px 30px;
    border-radius: 99px;
    cursor: pointer;
    transition: border-color 0.2s, color 0.2s, box-shadow 0.2s;
    flex-shrink: 0;
    -webkit-tap-highlight-color: transparent;
  }

  .reset-btn:active,
  .reset-btn:hover {
    border-color: #ff2b2b;
    color: #ff2b2b;
    box-shadow: 0 0 18px rgba(255,43,43,0.15);
  }
</style>
</head>
<body>

<h1>Scratch & Reveal</h1>
<p class="subtitle">Rub to uncover what's beneath</p>

<div class="canvas-wrapper" id="wrapper">
  <img id="reveal-image"
    src="https://picsum.photos/seed/redreveal/960/640"
    alt="Hidden image"
    crossorigin="anonymous"
    draggable="false"
  />
  <canvas id="scratch-canvas"></canvas>
</div>

<div class="progress-bar-wrap" id="prog-wrap">
  <div class="progress-bar" id="progress-bar"></div>
</div>
<p class="hint">Rub your finger to scratch away the red</p>
<button class="reset-btn" id="reset-btn">↺ Reset</button>

<script>
  const canvas      = document.getElementById('scratch-canvas');
  const ctx         = canvas.getContext('2d', { willReadFrequently: true });
  const img         = document.getElementById('reveal-image');
  const wrapper     = document.getElementById('wrapper');
  const progWrap    = document.getElementById('prog-wrap');
  const progressBar = document.getElementById('progress-bar');
  const resetBtn    = document.getElementById('reset-btn');

  let isDrawing = false;
  let lastX = null, lastY = null;
  let lastCheckTime = 0;

  /* ── Size the canvas to fit screen ── */
  function calcSize() {
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const titleEl    = document.querySelector('h1');
    const subtitleEl = document.querySelector('.subtitle');
    const hintEl     = document.querySelector('.hint');
    const btnEl      = resetBtn;

    // Measure fixed UI elements
    const titleH    = titleEl.offsetHeight + 4;
    const subH      = subtitleEl.offsetHeight + parseFloat(getComputedStyle(subtitleEl).marginBottom);
    const progressH = 12 + 3;
    const hintH     = 10 + hintEl.offsetHeight;
    const btnH      = parseFloat(getComputedStyle(btnEl).marginTop) + btnEl.offsetHeight;
    const padV      = 32;

    const usedH = padV + titleH + subH + progressH + hintH + btnH + 20;
    const availH = vh - usedH;
    const availW = Math.min(vw - 32, 520);

    const aspect = 960 / 640;
    let w = availW;
    let h = w / aspect;
    if (h > availH) { h = availH; w = h * aspect; }

    return { w: Math.floor(w), h: Math.floor(h) };
  }

  /* ── Paint a solid red layer on the canvas ── */
  function initCanvas() {
    const { w, h } = calcSize();

    wrapper.style.width  = w + 'px';
    wrapper.style.height = h + 'px';
    progWrap.style.width = w + 'px';

    // Set the actual pixel dimensions — this also clears the canvas
    canvas.width  = w;
    canvas.height = h;

    // Reset composite mode before drawing
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;

    // Solid red fill — NO transparency, NO gradient tricks that cause opacity
    ctx.fillStyle = '#cc1a1a';
    ctx.fillRect(0, 0, w, h);

    // Light scanline texture for depth
    ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    ctx.lineWidth = 1;
    for (let y = 0; y < h; y += 5) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }

    // Subtle ghost text hint
    ctx.fillStyle = 'rgba(255,255,255,0.055)';
    ctx.font = `bold ${Math.floor(w * 0.09)}px Arial, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('SCRATCH HERE', w / 2, h / 2);

    // Reset state
    lastX = null;
    lastY = null;
    progressBar.style.width = '0%';
  }

  /* ── Get touch/mouse position relative to canvas pixels ── */
  function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    // Scale from CSS size to actual pixel size
    const scaleX = canvas.width  / rect.width;
    const scaleY = canvas.height / rect.height;
    const src = e.touches ? e.touches[0] : e;
    return {
      x: (src.clientX - rect.left) * scaleX,
      y: (src.clientY - rect.top)  * scaleY
    };
  }

  /* ── Brush size scales with canvas ── */
  function brushR() {
    return Math.max(30, canvas.width * 0.075);
  }

  /* ── Scratch: punch a clean hole using destination-out ── */
  function scratchAt(x, y) {
    // destination-out erases pixels on the canvas, showing the image below
    ctx.globalCompositeOperation = 'destination-out';
    ctx.globalAlpha = 1; // MUST be 1 — any alpha < 1 causes semi-transparent edges (the "opacity" bug)

    const r = brushR();
    ctx.lineJoin  = 'round';
    ctx.lineCap   = 'round';
    ctx.lineWidth = r * 2;

    ctx.beginPath();
    if (lastX !== null) {
      // Draw a thick line from last point to current — fills gaps during fast movement
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(x, y);
    } else {
      ctx.moveTo(x, y);
      ctx.lineTo(x + 0.1, y); // tiny nudge so stroke renders on a single tap
    }
    ctx.stroke();

    lastX = x;
    lastY = y;
  }

  /* ── Progress tracking (throttled for performance) ── */
  function updateProgress() {
    const now = Date.now();
    if (now - lastCheckTime < 200) return;
    lastCheckTime = now;

    // Sample every 4th pixel (stride of 16 bytes) — fast enough
    const data   = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    let   erased = 0;
    const stride = 16;
    const total  = Math.floor(data.length / stride);
    for (let i = 3; i < data.length; i += stride) {
      if (data[i] < 128) erased++;
    }

    const pct = Math.min((erased / total) * 100, 100);
    progressBar.style.width = pct + '%';
    // No auto-reveal — user scratches as much or as little as they want
  }

  /* ── Event handlers ── */
  function onStart(e) {
    e.preventDefault();
    isDrawing = true;
    lastX = null;
    lastY = null;
    const p = getPos(e);
    scratchAt(p.x, p.y);
  }

  function onMove(e) {
    e.preventDefault();
    if (!isDrawing) return;
    const p = getPos(e);
    scratchAt(p.x, p.y);
    updateProgress();
  }

  function onEnd(e) {
    if (e) e.preventDefault();
    isDrawing = false;
    lastX = null;
    lastY = null;
  }

  // Mouse
  canvas.addEventListener('mousedown',  onStart, { passive: false });
  canvas.addEventListener('mousemove',  onMove,  { passive: false });
  canvas.addEventListener('mouseup',    onEnd,   { passive: false });
  canvas.addEventListener('mouseleave', onEnd,   { passive: false });

  // Touch
  canvas.addEventListener('touchstart',  onStart, { passive: false });
  canvas.addEventListener('touchmove',   onMove,  { passive: false });
  canvas.addEventListener('touchend',    onEnd,   { passive: false });
  canvas.addEventListener('touchcancel', onEnd,   { passive: false });

  // Reset button — only way to restore the red layer
  resetBtn.addEventListener('click', initCanvas);

  // Recalculate on orientation change / resize
  window.addEventListener('resize', initCanvas);

  /* ── Boot ── */
  function boot() {
    document.fonts.ready.then(initCanvas).catch(initCanvas);
  }

  if (img.complete && img.naturalWidth > 0) {
    boot();
  } else {
    img.addEventListener('load', boot);
    img.addEventListener('error', boot);
  }
</script>
</body>
</html>
